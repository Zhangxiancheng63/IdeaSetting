<application>
  <component name="AppStorage">
    <histories>
      <item value="last Index Of Supplementary" />
      <item value="MIN SUPPLEMENTARY CODE POINT" />
      <item value="SUPPLEMENTARY" />
      <item value="Enumeration" />
      <item value="Malformed" />
      <item value="public" />
      <item value="图" />
      <item value="图则" />
      <item value="Cabinet" />
      <item value="Indicator" />
      <item value="d" />
      <item value="JCQLHFGL" />
      <item value="push For Birthday" />
      <item value="third" />
      <item value="partitions" />
      <item value="Social" />
      <item value="bubbles" />
      <item value="Scene" />
      <item value="assmbly" />
      <item value="assembly" />
      <item value="judge" />
      <item value="isolation" />
      <item value="Join Relay" />
      <item value="Relay" />
      <item value="new" />
      <item value="mobile" />
      <item value="Historic" />
      <item value="Wrap" />
      <item value="Briefing" />
      <item value="Various flavors of acquire, varying in exclusive/shared and * control modes. Each is mostly the same, but annoyingly * different. Only a little bit of factoring is possible due to * interactions of exception mechanics (including ensuring that we * cancel if tryAcquire throws exception) and other control, at * least not without hurting performance too much." />
      <item value="Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire." />
      <item value="signal" />
      <item value="Predecessor was cancelled. Skip over predecessors and * indicate retry" />
      <item value="acquire" />
      <item value="Used by condition wait methods as well as acquire" />
      <item value="conveyed" />
      <item value="Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire" />
      <item value="A releaseShared should be propagated to other * nodes. This is set (for head node only) in * doReleaseShared to ensure propagation * continues, even if other operations have * since intervened" />
      <item value="but simplifies mechanics" />
      <item value="mechanics" />
      <item value="It will not be used as a sync queue node * until transferred" />
      <item value="successor" />
      <item value="The successor of this node is (or will soon be) * blocked (via park), so the current node must * unpark its successor when it releases or * cancels. To avoid races, acquire methods must * first indicate they need a signal, * then retry the atomic acquire, and then, * on failure, block" />
      <item value="Craig, Landin, and * Hagersten" />
      <item value="whatsoever" />
      <item value="operating * off" />
      <item value="Unlike the otherwise equivalent * {@code newFixedThreadPool(1)} the returned executor is * guaranteed not to be reconfigurable to use additional threads." />
      <item value="sequentially" />
      <item value="subsequent tasks" />
      <item value="prior" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="273" />
        <entry key="ENGLISH" value="274" />
        <entry key="ALBANIAN" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="GREEK" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1612486198489" />
  </component>
</application>