<application>
  <component name="AppStorage">
    <histories>
      <item value="push For Birthday" />
      <item value="third" />
      <item value="partitions" />
      <item value="Social" />
      <item value="bubbles" />
      <item value="Scene" />
      <item value="assmbly" />
      <item value="assembly" />
      <item value="judge" />
      <item value="isolation" />
      <item value="Join Relay" />
      <item value="Relay" />
      <item value="new" />
      <item value="mobile" />
      <item value="Historic" />
      <item value="Wrap" />
      <item value="Briefing" />
      <item value="Various flavors of acquire, varying in exclusive/shared and * control modes. Each is mostly the same, but annoyingly * different. Only a little bit of factoring is possible due to * interactions of exception mechanics (including ensuring that we * cancel if tryAcquire throws exception) and other control, at * least not without hurting performance too much." />
      <item value="Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire." />
      <item value="signal" />
      <item value="Predecessor was cancelled. Skip over predecessors and * indicate retry" />
      <item value="acquire" />
      <item value="Used by condition wait methods as well as acquire" />
      <item value="conveyed" />
      <item value="Acquires in exclusive uninterruptible mode for thread already in * queue. Used by condition wait methods as well as acquire" />
      <item value="A releaseShared should be propagated to other * nodes. This is set (for head node only) in * doReleaseShared to ensure propagation * continues, even if other operations have * since intervened" />
      <item value="but simplifies mechanics" />
      <item value="mechanics" />
      <item value="It will not be used as a sync queue node * until transferred" />
      <item value="successor" />
      <item value="The successor of this node is (or will soon be) * blocked (via park), so the current node must * unpark its successor when it releases or * cancels. To avoid races, acquire methods must * first indicate they need a signal, * then retry the atomic acquire, and then, * on failure, block" />
      <item value="Craig, Landin, and * Hagersten" />
      <item value="whatsoever" />
      <item value="operating * off" />
      <item value="Unlike the otherwise equivalent * {@code newFixedThreadPool(1)} the returned executor is * guaranteed not to be reconfigurable to use additional threads." />
      <item value="sequentially" />
      <item value="subsequent tasks" />
      <item value="prior" />
      <item value="unbounded queue" />
      <item value="to reduce footprint" />
      <item value="Sets this Future to the result of its computation * unless it has been cancelled" />
      <item value="closure-like" />
      <item value="state" />
      <item value="Methods that create and return a &quot;wrapped&quot; ExecutorService, that * disables reconfiguration by making implementation-specific methods * inaccessible" />
      <item value="Invoice" />
      <item value="implements" />
      <item value="requestVolumeThreshold" />
      <item value="Single Candidate" />
      <item value="Use names and ensure unique to protect against duplicates" />
      <item value="Store" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="263" />
        <entry key="ENGLISH" value="264" />
        <entry key="ALBANIAN" value="1" />
        <entry key="GERMAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="KURDISH" value="1" />
        <entry key="ROMANIAN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="GREEK" value="1" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1607581538729" />
  </component>
</application>